	The main header file for this simulation, "queue.h" includes datastructures for a FIFO queue, and a priority queue called "job_list." Both of these datastructures use the "job" struct as nodes, which contain a "time" being the priority, an enumerated "type," indicating the type of job to be processed, and a pointer to the next job. Functions include enqueueing and dequeueing for each queue, and printing, as well as functions to delete and free the datastructures.
	The FIFO queue uses a basic add and remove function where priority is ignored, while the priority queue ensures that new jobs are sorted into the queue when added. Because only one node is added at a time, the sorting function is O(n).
	The file "simulator.c" contains general functions for running the simulation. Main() initializes global parameters by parsing a "config" file, and parameters are used in initializing jobs, and determining random times for processes. Main initializes the queue datastructures, starting and ending jobs, variables for performing statistics, and opens a log file to record the parameters.
	The main loop operates as long as the event queue contains elements and the time for the next element is less than the FIN_TIME parameter. It pops a job from the event queue, and adds an initial job to the event queue at a random time based on ARRIVAL_MIN and ARRIVAL_MAX. The job time and type are written to the log file, and then the job type is tested. Jobs be one of four types, depending on the last process they were in. Counters for statistics are incremented depending on the type and then the job is dispatched to one of four handlers. The arrival_handler() takes initial jobs, and dispatches them to the cpu, the cpu_finished_handler() takes jobs and tests them for quitting, then determines what disk to dispatch them to depending on the sizes of the disk queues. The disk handlers will determine a process time for the job, and then return them to the event queue to be dispatched to the cpu. After the simulation has completed, statistics are processed in bulk, and written to the log file and then the file is closed and datastructures are freed.
	Times for jobs are calculated very simply. To determine the time of the process, rand() is called for some random numbed, and then modded to be within the range of MAX and MIN in the global parameters, then MIN is added.
	The range of arrival times for initial events cause much of the variance throughout the simulation. As it runs, events tend to group up in the upper ranges of times, and if the arrival time is too low of a range, then events cluster earlier in the simulation. The effect of ARRIVE_MAX is almost exponential on the number of events processed within the simulation time. Too high of a range prevents enough jobs from being added, while too low of a range causes so many jobs to cluster that the simulation never exits.
